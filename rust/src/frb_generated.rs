// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.9.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 199121248;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__warp__check_account_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "check_account",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            let api_id = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::warp::check_account(api_coin, api_id))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__simple__create_election_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_election",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filepath = <String>::sse_decode(&mut deserializer);
            let api_urls = <String>::sse_decode(&mut deserializer);
            let api_lwd_url = <String>::sse_decode(&mut deserializer);
            let api_key = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::simple::create_election(
                            api_filepath,
                            api_urls,
                            api_lwd_url,
                            api_key,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__warp__decode_payment_URI_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decode_payment_URI",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            let api_uri = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::warp::decode_payment_URI(api_coin, &api_uri)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__simple__download_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "download",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filepath = <String>::sse_decode(&mut deserializer);
            let api_height =
                <StreamSink<u32, flutter_rust_bridge::for_generated::SseCodec>>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::simple::download(api_filepath, api_height).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__simple__dummy_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dummy",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api__a1 = <crate::types::PoolBalance>::sse_decode(&mut deserializer);
            let api__a2 = <crate::types::Spending>::sse_decode(&mut deserializer);
            let api__a3 = <crate::types::TxTimeValue>::sse_decode(&mut deserializer);
            let api__a4 = <crate::types::Quote>::sse_decode(&mut deserializer);
            let api__a5 = <crate::types::Fee>::sse_decode(&mut deserializer);
            let api__a6 = <crate::types::Progress>::sse_decode(&mut deserializer);
            let api__a7 = <crate::types::Contact>::sse_decode(&mut deserializer);
            let api__a8 = <crate::types::TxMemo>::sse_decode(&mut deserializer);
            let api__a9 = <crate::types::ShieldedNote>::sse_decode(&mut deserializer);
            let api__a10 = <crate::types::ParsedMemo>::sse_decode(&mut deserializer);
            let api__a11 = <crate::types::SendContext>::sse_decode(&mut deserializer);
            let api__a12 = <crate::types::PaymentURI>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::simple::dummy(
                        &api__a1, &api__a2, &api__a3, &api__a4, &api__a5, &api__a6, &api__a7,
                        &api__a8, &api__a9, &api__a10, &api__a11, &api__a12,
                    );
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__simple__getBackup_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "getBackup",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            let api_id = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::simple::getBackup(api_coin, api_id)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__simple__get_balance_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_balance",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filepath = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::simple::get_balance(api_filepath)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__warp__get_contacts_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_contacts",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::warp::get_contacts(api_coin)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__warp__get_db_height_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_db_height",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::warp::get_db_height(api_coin))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__warp__get_diversified_address_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_diversified_address",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            let api_id = <u32>::sse_decode(&mut deserializer);
            let api_mask = <u8>::sse_decode(&mut deserializer);
            let api_time = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::warp::get_diversified_address(
                    api_coin, api_id, api_mask, api_time,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__simple__get_election_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_election",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filepath = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::simple::get_election(api_filepath)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__warp__get_first_account_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_first_account",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::warp::get_first_account(api_coin))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__warp__get_latest_height_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_latest_height",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::warp::get_latest_height(api_coin)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__warp__get_pnl_txs_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_pnl_txs",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            let api_id = <u32>::sse_decode(&mut deserializer);
            let api_start = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::warp::get_pnl_txs(api_coin, api_id, api_start)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__warp__get_pool_balances_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_pool_balances",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            let api_id = <u32>::sse_decode(&mut deserializer);
            let api_confs = <u32>::sse_decode(&mut deserializer);
            let api_unconfirmed = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::warp::get_pool_balances(
                    api_coin,
                    api_id,
                    api_confs,
                    api_unconfirmed,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__warp__get_property_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_property",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            let api_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::warp::get_property(api_coin, &api_name))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__warp__get_spendings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_spendings",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            let api_id = <u32>::sse_decode(&mut deserializer);
            let api_start = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::warp::get_spendings(api_coin, api_id, api_start)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__simple__init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::simple::init_app();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__warp__init_prover_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_prover",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_spend = <Vec<u8>>::sse_decode(&mut deserializer);
            let api_output = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::warp::init_prover(&api_spend, &api_output)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__warp__init_wallet_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_wallet",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::warp::init_wallet(api_coin, &api_path);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__simple__list_votes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "list_votes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filepath = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::simple::list_votes(api_filepath)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__warp__rescan_from_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "rescan_from",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            let api_height = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::warp::rescan_from(api_coin, api_height);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__warp__set_db_passwd_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_db_passwd",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::warp::set_db_passwd(api_coin, &api_password);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__warp__store_contact_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "store_contact",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            let api_id = <u32>::sse_decode(&mut deserializer);
            let api_contact = <crate::types::Contact>::sse_decode(&mut deserializer);
            let api_dirty = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::warp::store_contact(api_coin, api_id, api_contact, api_dirty)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__simple__synchronize_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "synchronize",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filepath = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok = crate::api::simple::synchronize(api_filepath).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__warp__update_lwd_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_lwd",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            let api_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::warp::update_lwd(api_coin, &api_url);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__simple__vote_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "vote",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filepath = <String>::sse_decode(&mut deserializer);
            let api_address = <String>::sse_decode(&mut deserializer);
            let api_amount = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let output_ok =
                            crate::api::simple::vote(api_filepath, api_address, api_amount).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__warp__warp_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "warp_sync",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_coin = <u8>::sse_decode(&mut deserializer);
            let api_id = <u32>::sse_decode(&mut deserializer);
            let api_inc_txs = <bool>::sse_decode(&mut deserializer);
            let api_confs = <u32>::sse_decode(&mut deserializer);
            let api_max_actions = <u32>::sse_decode(&mut deserializer);
            let api_progress = <StreamSink<
                crate::types::Progress,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = crate::api::warp::warp_sync(
                            api_coin,
                            api_id,
                            api_inc_txs,
                            api_confs,
                            api_max_actions,
                            api_progress,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode
    for StreamSink<crate::types::Progress, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for StreamSink<u32, flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::types::Backup {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_seed = <Option<String>>::sse_decode(deserializer);
        let mut var_index = <u32>::sse_decode(deserializer);
        let mut var_sk = <Option<String>>::sse_decode(deserializer);
        let mut var_fvk = <String>::sse_decode(deserializer);
        let mut var_uvk = <String>::sse_decode(deserializer);
        let mut var_tsk = <Option<String>>::sse_decode(deserializer);
        let mut var_saved = <bool>::sse_decode(deserializer);
        return crate::types::Backup {
            name: var_name,
            seed: var_seed,
            index: var_index,
            sk: var_sk,
            fvk: var_fvk,
            uvk: var_uvk,
            tsk: var_tsk,
            saved: var_saved,
        };
    }
}

impl SseDecode for crate::types::BlockHeight {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_height = <u32>::sse_decode(deserializer);
        let mut var_timestamp = <u32>::sse_decode(deserializer);
        return crate::types::BlockHeight {
            height: var_height,
            timestamp: var_timestamp,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::simple::Choice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_choice = <String>::sse_decode(deserializer);
        let mut var_address = <String>::sse_decode(deserializer);
        return crate::api::simple::Choice {
            choice: var_choice,
            address: var_address,
        };
    }
}

impl SseDecode for crate::types::Contact {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <u32>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_address = <String>::sse_decode(deserializer);
        return crate::types::Contact {
            id: var_id,
            name: var_name,
            address: var_address,
        };
    }
}

impl SseDecode for crate::api::simple::Election {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_startHeight = <u32>::sse_decode(deserializer);
        let mut var_endHeight = <u32>::sse_decode(deserializer);
        let mut var_question = <String>::sse_decode(deserializer);
        let mut var_candidates = <Vec<crate::api::simple::Choice>>::sse_decode(deserializer);
        let mut var_signatureRequired = <bool>::sse_decode(deserializer);
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_downloaded = <bool>::sse_decode(deserializer);
        return crate::api::simple::Election {
            id: var_id,
            name: var_name,
            start_height: var_startHeight,
            end_height: var_endHeight,
            question: var_question,
            candidates: var_candidates,
            signature_required: var_signatureRequired,
            address: var_address,
            downloaded: var_downloaded,
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::types::Fee {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_scheme = <u8>::sse_decode(deserializer);
        let mut var_fee = <u64>::sse_decode(deserializer);
        return crate::types::Fee {
            scheme: var_scheme,
            fee: var_fee,
        };
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for Vec<crate::api::simple::Choice> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::simple::Choice>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::types::Contact> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::types::Contact>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::types::Spending> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::types::Spending>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::types::TxTimeValue> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::types::TxTimeValue>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::simple::Vote> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::simple::Vote>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::types::ParsedMemo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_reply = <bool>::sse_decode(deserializer);
        let mut var_subject = <String>::sse_decode(deserializer);
        let mut var_memo = <String>::sse_decode(deserializer);
        return crate::types::ParsedMemo {
            reply: var_reply,
            subject: var_subject,
            memo: var_memo,
        };
    }
}

impl SseDecode for crate::types::PaymentURI {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_amount = <u64>::sse_decode(deserializer);
        let mut var_memo = <String>::sse_decode(deserializer);
        return crate::types::PaymentURI {
            address: var_address,
            amount: var_amount,
            memo: var_memo,
        };
    }
}

impl SseDecode for crate::types::PoolBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_transparent = <u64>::sse_decode(deserializer);
        let mut var_sapling = <u64>::sse_decode(deserializer);
        let mut var_orchard = <u64>::sse_decode(deserializer);
        return crate::types::PoolBalance {
            transparent: var_transparent,
            sapling: var_sapling,
            orchard: var_orchard,
        };
    }
}

impl SseDecode for crate::types::Progress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_timestamp = <u32>::sse_decode(deserializer);
        let mut var_trialDecryptions = <u32>::sse_decode(deserializer);
        let mut var_height = <u32>::sse_decode(deserializer);
        let mut var_downloaded = <u32>::sse_decode(deserializer);
        return crate::types::Progress {
            timestamp: var_timestamp,
            trial_decryptions: var_trialDecryptions,
            height: var_height,
            downloaded: var_downloaded,
        };
    }
}

impl SseDecode for crate::types::Quote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_timestamp = <u32>::sse_decode(deserializer);
        let mut var_price = <f64>::sse_decode(deserializer);
        return crate::types::Quote {
            timestamp: var_timestamp,
            price: var_price,
        };
    }
}

impl SseDecode for crate::types::SendContext {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_pools = <u8>::sse_decode(deserializer);
        let mut var_amount = <u64>::sse_decode(deserializer);
        let mut var_receiverFee = <bool>::sse_decode(deserializer);
        let mut var_memo = <crate::types::ParsedMemo>::sse_decode(deserializer);
        return crate::types::SendContext {
            address: var_address,
            pools: var_pools,
            amount: var_amount,
            receiver_fee: var_receiverFee,
            memo: var_memo,
        };
    }
}

impl SseDecode for crate::types::ShieldedNote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <u32>::sse_decode(deserializer);
        let mut var_height = <u32>::sse_decode(deserializer);
        let mut var_value = <u64>::sse_decode(deserializer);
        let mut var_timestamp = <u32>::sse_decode(deserializer);
        let mut var_orchard = <bool>::sse_decode(deserializer);
        let mut var_excluded = <bool>::sse_decode(deserializer);
        let mut var_spent = <bool>::sse_decode(deserializer);
        return crate::types::ShieldedNote {
            id: var_id,
            height: var_height,
            value: var_value,
            timestamp: var_timestamp,
            orchard: var_orchard,
            excluded: var_excluded,
            spent: var_spent,
        };
    }
}

impl SseDecode for crate::types::Spending {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_recipient = <String>::sse_decode(deserializer);
        let mut var_amount = <i64>::sse_decode(deserializer);
        return crate::types::Spending {
            recipient: var_recipient,
            amount: var_amount,
        };
    }
}

impl SseDecode for crate::types::TxMemo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_direction = <u8>::sse_decode(deserializer);
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_memo = <String>::sse_decode(deserializer);
        return crate::types::TxMemo {
            direction: var_direction,
            address: var_address,
            memo: var_memo,
        };
    }
}

impl SseDecode for crate::types::TxTimeValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_timestamp = <u32>::sse_decode(deserializer);
        let mut var_value = <i64>::sse_decode(deserializer);
        return crate::types::TxTimeValue {
            timestamp: var_timestamp,
            value: var_value,
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::api::simple::Vote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hash = <String>::sse_decode(deserializer);
        let mut var_address = <String>::sse_decode(deserializer);
        let mut var_amount = <u64>::sse_decode(deserializer);
        let mut var_height = <Option<u32>>::sse_decode(deserializer);
        return crate::api::simple::Vote {
            hash: var_hash,
            address: var_address,
            amount: var_amount,
            height: var_height,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        2 => wire__crate__api__simple__create_election_impl(port, ptr, rust_vec_len, data_len),
        4 => wire__crate__api__simple__download_impl(port, ptr, rust_vec_len, data_len),
        7 => wire__crate__api__simple__get_balance_impl(port, ptr, rust_vec_len, data_len),
        8 => wire__crate__api__warp__get_contacts_impl(port, ptr, rust_vec_len, data_len),
        11 => wire__crate__api__simple__get_election_impl(port, ptr, rust_vec_len, data_len),
        13 => wire__crate__api__warp__get_latest_height_impl(port, ptr, rust_vec_len, data_len),
        14 => wire__crate__api__warp__get_pnl_txs_impl(port, ptr, rust_vec_len, data_len),
        17 => wire__crate__api__warp__get_spendings_impl(port, ptr, rust_vec_len, data_len),
        18 => wire__crate__api__simple__init_app_impl(port, ptr, rust_vec_len, data_len),
        21 => wire__crate__api__simple__list_votes_impl(port, ptr, rust_vec_len, data_len),
        25 => wire__crate__api__simple__synchronize_impl(port, ptr, rust_vec_len, data_len),
        27 => wire__crate__api__simple__vote_impl(port, ptr, rust_vec_len, data_len),
        28 => wire__crate__api__warp__warp_sync_impl(port, ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__warp__check_account_impl(ptr, rust_vec_len, data_len),
        3 => wire__crate__api__warp__decode_payment_URI_impl(ptr, rust_vec_len, data_len),
        5 => wire__crate__api__simple__dummy_impl(ptr, rust_vec_len, data_len),
        6 => wire__crate__api__simple__getBackup_impl(ptr, rust_vec_len, data_len),
        9 => wire__crate__api__warp__get_db_height_impl(ptr, rust_vec_len, data_len),
        10 => wire__crate__api__warp__get_diversified_address_impl(ptr, rust_vec_len, data_len),
        12 => wire__crate__api__warp__get_first_account_impl(ptr, rust_vec_len, data_len),
        15 => wire__crate__api__warp__get_pool_balances_impl(ptr, rust_vec_len, data_len),
        16 => wire__crate__api__warp__get_property_impl(ptr, rust_vec_len, data_len),
        19 => wire__crate__api__warp__init_prover_impl(ptr, rust_vec_len, data_len),
        20 => wire__crate__api__warp__init_wallet_impl(ptr, rust_vec_len, data_len),
        22 => wire__crate__api__warp__rescan_from_impl(ptr, rust_vec_len, data_len),
        23 => wire__crate__api__warp__set_db_passwd_impl(ptr, rust_vec_len, data_len),
        24 => wire__crate__api__warp__store_contact_impl(ptr, rust_vec_len, data_len),
        26 => wire__crate__api__warp__update_lwd_impl(ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::Backup {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.seed.into_into_dart().into_dart(),
            self.index.into_into_dart().into_dart(),
            self.sk.into_into_dart().into_dart(),
            self.fvk.into_into_dart().into_dart(),
            self.uvk.into_into_dart().into_dart(),
            self.tsk.into_into_dart().into_dart(),
            self.saved.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::types::Backup {}
impl flutter_rust_bridge::IntoIntoDart<crate::types::Backup> for crate::types::Backup {
    fn into_into_dart(self) -> crate::types::Backup {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::BlockHeight {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.height.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::types::BlockHeight {}
impl flutter_rust_bridge::IntoIntoDart<crate::types::BlockHeight> for crate::types::BlockHeight {
    fn into_into_dart(self) -> crate::types::BlockHeight {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::simple::Choice {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.choice.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::simple::Choice {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::simple::Choice> for crate::api::simple::Choice {
    fn into_into_dart(self) -> crate::api::simple::Choice {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::Contact {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::types::Contact {}
impl flutter_rust_bridge::IntoIntoDart<crate::types::Contact> for crate::types::Contact {
    fn into_into_dart(self) -> crate::types::Contact {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::simple::Election {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.start_height.into_into_dart().into_dart(),
            self.end_height.into_into_dart().into_dart(),
            self.question.into_into_dart().into_dart(),
            self.candidates.into_into_dart().into_dart(),
            self.signature_required.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
            self.downloaded.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::simple::Election {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::simple::Election>
    for crate::api::simple::Election
{
    fn into_into_dart(self) -> crate::api::simple::Election {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::Fee {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.scheme.into_into_dart().into_dart(),
            self.fee.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::types::Fee {}
impl flutter_rust_bridge::IntoIntoDart<crate::types::Fee> for crate::types::Fee {
    fn into_into_dart(self) -> crate::types::Fee {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::ParsedMemo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.reply.into_into_dart().into_dart(),
            self.subject.into_into_dart().into_dart(),
            self.memo.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::types::ParsedMemo {}
impl flutter_rust_bridge::IntoIntoDart<crate::types::ParsedMemo> for crate::types::ParsedMemo {
    fn into_into_dart(self) -> crate::types::ParsedMemo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::PaymentURI {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.address.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
            self.memo.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::types::PaymentURI {}
impl flutter_rust_bridge::IntoIntoDart<crate::types::PaymentURI> for crate::types::PaymentURI {
    fn into_into_dart(self) -> crate::types::PaymentURI {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::PoolBalance {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.transparent.into_into_dart().into_dart(),
            self.sapling.into_into_dart().into_dart(),
            self.orchard.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::types::PoolBalance {}
impl flutter_rust_bridge::IntoIntoDart<crate::types::PoolBalance> for crate::types::PoolBalance {
    fn into_into_dart(self) -> crate::types::PoolBalance {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::Progress {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.timestamp.into_into_dart().into_dart(),
            self.trial_decryptions.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
            self.downloaded.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::types::Progress {}
impl flutter_rust_bridge::IntoIntoDart<crate::types::Progress> for crate::types::Progress {
    fn into_into_dart(self) -> crate::types::Progress {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::Quote {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.timestamp.into_into_dart().into_dart(),
            self.price.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::types::Quote {}
impl flutter_rust_bridge::IntoIntoDart<crate::types::Quote> for crate::types::Quote {
    fn into_into_dart(self) -> crate::types::Quote {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::SendContext {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.address.into_into_dart().into_dart(),
            self.pools.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
            self.receiver_fee.into_into_dart().into_dart(),
            self.memo.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::types::SendContext {}
impl flutter_rust_bridge::IntoIntoDart<crate::types::SendContext> for crate::types::SendContext {
    fn into_into_dart(self) -> crate::types::SendContext {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::ShieldedNote {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
            self.orchard.into_into_dart().into_dart(),
            self.excluded.into_into_dart().into_dart(),
            self.spent.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::types::ShieldedNote {}
impl flutter_rust_bridge::IntoIntoDart<crate::types::ShieldedNote> for crate::types::ShieldedNote {
    fn into_into_dart(self) -> crate::types::ShieldedNote {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::Spending {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.recipient.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::types::Spending {}
impl flutter_rust_bridge::IntoIntoDart<crate::types::Spending> for crate::types::Spending {
    fn into_into_dart(self) -> crate::types::Spending {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::TxMemo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.direction.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
            self.memo.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::types::TxMemo {}
impl flutter_rust_bridge::IntoIntoDart<crate::types::TxMemo> for crate::types::TxMemo {
    fn into_into_dart(self) -> crate::types::TxMemo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::types::TxTimeValue {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.timestamp.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::types::TxTimeValue {}
impl flutter_rust_bridge::IntoIntoDart<crate::types::TxTimeValue> for crate::types::TxTimeValue {
    fn into_into_dart(self) -> crate::types::TxTimeValue {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::simple::Vote {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.hash.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
            self.amount.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::simple::Vote {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::simple::Vote> for crate::api::simple::Vote {
    fn into_into_dart(self) -> crate::api::simple::Vote {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode
    for StreamSink<crate::types::Progress, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for StreamSink<u32, flutter_rust_bridge::for_generated::SseCodec> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::types::Backup {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <Option<String>>::sse_encode(self.seed, serializer);
        <u32>::sse_encode(self.index, serializer);
        <Option<String>>::sse_encode(self.sk, serializer);
        <String>::sse_encode(self.fvk, serializer);
        <String>::sse_encode(self.uvk, serializer);
        <Option<String>>::sse_encode(self.tsk, serializer);
        <bool>::sse_encode(self.saved, serializer);
    }
}

impl SseEncode for crate::types::BlockHeight {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.height, serializer);
        <u32>::sse_encode(self.timestamp, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::simple::Choice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.choice, serializer);
        <String>::sse_encode(self.address, serializer);
    }
}

impl SseEncode for crate::types::Contact {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.address, serializer);
    }
}

impl SseEncode for crate::api::simple::Election {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.name, serializer);
        <u32>::sse_encode(self.start_height, serializer);
        <u32>::sse_encode(self.end_height, serializer);
        <String>::sse_encode(self.question, serializer);
        <Vec<crate::api::simple::Choice>>::sse_encode(self.candidates, serializer);
        <bool>::sse_encode(self.signature_required, serializer);
        <String>::sse_encode(self.address, serializer);
        <bool>::sse_encode(self.downloaded, serializer);
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::types::Fee {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u8>::sse_encode(self.scheme, serializer);
        <u64>::sse_encode(self.fee, serializer);
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for Vec<crate::api::simple::Choice> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::simple::Choice>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::types::Contact> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::types::Contact>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::types::Spending> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::types::Spending>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::types::TxTimeValue> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::types::TxTimeValue>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::simple::Vote> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::simple::Vote>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::types::ParsedMemo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.reply, serializer);
        <String>::sse_encode(self.subject, serializer);
        <String>::sse_encode(self.memo, serializer);
    }
}

impl SseEncode for crate::types::PaymentURI {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
        <u64>::sse_encode(self.amount, serializer);
        <String>::sse_encode(self.memo, serializer);
    }
}

impl SseEncode for crate::types::PoolBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.transparent, serializer);
        <u64>::sse_encode(self.sapling, serializer);
        <u64>::sse_encode(self.orchard, serializer);
    }
}

impl SseEncode for crate::types::Progress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.timestamp, serializer);
        <u32>::sse_encode(self.trial_decryptions, serializer);
        <u32>::sse_encode(self.height, serializer);
        <u32>::sse_encode(self.downloaded, serializer);
    }
}

impl SseEncode for crate::types::Quote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.timestamp, serializer);
        <f64>::sse_encode(self.price, serializer);
    }
}

impl SseEncode for crate::types::SendContext {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.address, serializer);
        <u8>::sse_encode(self.pools, serializer);
        <u64>::sse_encode(self.amount, serializer);
        <bool>::sse_encode(self.receiver_fee, serializer);
        <crate::types::ParsedMemo>::sse_encode(self.memo, serializer);
    }
}

impl SseEncode for crate::types::ShieldedNote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.id, serializer);
        <u32>::sse_encode(self.height, serializer);
        <u64>::sse_encode(self.value, serializer);
        <u32>::sse_encode(self.timestamp, serializer);
        <bool>::sse_encode(self.orchard, serializer);
        <bool>::sse_encode(self.excluded, serializer);
        <bool>::sse_encode(self.spent, serializer);
    }
}

impl SseEncode for crate::types::Spending {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.recipient, serializer);
        <i64>::sse_encode(self.amount, serializer);
    }
}

impl SseEncode for crate::types::TxMemo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u8>::sse_encode(self.direction, serializer);
        <String>::sse_encode(self.address, serializer);
        <String>::sse_encode(self.memo, serializer);
    }
}

impl SseEncode for crate::types::TxTimeValue {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.timestamp, serializer);
        <i64>::sse_encode(self.value, serializer);
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::api::simple::Vote {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.hash, serializer);
        <String>::sse_encode(self.address, serializer);
        <u64>::sse_encode(self.amount, serializer);
        <Option<u32>>::sse_encode(self.height, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();
}
#[cfg(target_family = "wasm")]
pub use web::*;
