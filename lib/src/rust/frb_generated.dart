// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/simple.dart';
import 'api/warp.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiSimpleInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.9.0';

  @override
  int get rustContentHash => 1767815544;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rust_lib_zwallet',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  bool crateApiWarpCheckAccount({required int coin, required int id});

  Future<Election> crateApiSimpleCreateElection(
      {required String filepath,
      required String urls,
      required String lwdUrl,
      required String key});

  PaymentURI crateApiWarpDecodePaymentUri(
      {required int coin, required String uri});

  Stream<int> crateApiSimpleDownload({required String filepath});

  void crateApiSimpleDummy(
      {required PoolBalance a1,
      required Spending a2,
      required TxTimeValue a3,
      required Quote a4,
      required Fee a5,
      required Progress a6,
      required Contact a7,
      required TxMemo a8,
      required ShieldedNote a9,
      required ParsedMemo a10,
      required SendContext a11,
      required PaymentURI a12,
      required Recipient a13,
      required Amount a14,
      required SwapAmount a15});

  Backup crateApiSimpleGetBackup({required int coin, required int id});

  Future<BigInt> crateApiSimpleGetBalance({required String filepath});

  Future<List<Contact>> crateApiWarpGetContacts({required int coin});

  BlockHeight crateApiWarpGetDbHeight({required int coin});

  String crateApiWarpGetDiversifiedAddress(
      {required int coin,
      required int id,
      required int mask,
      required int time});

  Future<Election> crateApiSimpleGetElection({required String filepath});

  int crateApiWarpGetFirstAccount({required int coin});

  Future<int> crateApiWarpGetLatestHeight({required int coin});

  Future<List<TxTimeValue>> crateApiWarpGetPnlTxs(
      {required int coin, required int id, required int start});

  PoolBalance crateApiWarpGetPoolBalances(
      {required int coin,
      required int id,
      required int confs,
      required bool unconfirmed});

  String? crateApiWarpGetProperty({required int coin, required String name});

  Future<List<Spending>> crateApiWarpGetSpendings(
      {required int coin, required int id, required int start});

  Future<void> crateApiSimpleInitApp();

  void crateApiWarpInitProver(
      {required List<int> spend, required List<int> output});

  void crateApiWarpInitWallet({required int coin, required String path});

  Future<List<Vote>> crateApiSimpleListVotes({required String filepath});

  void crateApiWarpRescanFrom({required int coin, required int height});

  void crateApiWarpSetDbPasswd({required int coin, required String password});

  List<String> crateApiWarpSplitData(
      {required int id, required List<int> data});

  void crateApiWarpStoreContact(
      {required int coin,
      required int id,
      required Contact contact,
      required bool dirty});

  Future<void> crateApiSimpleSynchronize({required String filepath});

  void crateApiWarpUpdateLwd({required int coin, required String url});

  Future<String> crateApiSimpleVote(
      {required String filepath,
      required String address,
      required BigInt amount});

  Stream<Progress> crateApiWarpWarpSync(
      {required int coin,
      required int id,
      required bool incTxs,
      required int confs,
      required int maxActions});
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  bool crateApiWarpCheckAccount({required int coin, required int id}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        sse_encode_u_8(id, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWarpCheckAccountConstMeta,
      argValues: [coin, id],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpCheckAccountConstMeta => const TaskConstMeta(
        debugName: "check_account",
        argNames: ["coin", "id"],
      );

  @override
  Future<Election> crateApiSimpleCreateElection(
      {required String filepath,
      required String urls,
      required String lwdUrl,
      required String key}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filepath, serializer);
        sse_encode_String(urls, serializer);
        sse_encode_String(lwdUrl, serializer);
        sse_encode_String(key, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_election,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleCreateElectionConstMeta,
      argValues: [filepath, urls, lwdUrl, key],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleCreateElectionConstMeta =>
      const TaskConstMeta(
        debugName: "create_election",
        argNames: ["filepath", "urls", "lwdUrl", "key"],
      );

  @override
  PaymentURI crateApiWarpDecodePaymentUri(
      {required int coin, required String uri}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        sse_encode_String(uri, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_payment_uri,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWarpDecodePaymentUriConstMeta,
      argValues: [coin, uri],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpDecodePaymentUriConstMeta =>
      const TaskConstMeta(
        debugName: "decode_payment_URI",
        argNames: ["coin", "uri"],
      );

  @override
  Stream<int> crateApiSimpleDownload({required String filepath}) {
    final height = RustStreamSink<int>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filepath, serializer);
        sse_encode_StreamSink_u_32_Sse(height, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleDownloadConstMeta,
      argValues: [filepath, height],
      apiImpl: this,
    )));
    return height.stream;
  }

  TaskConstMeta get kCrateApiSimpleDownloadConstMeta => const TaskConstMeta(
        debugName: "download",
        argNames: ["filepath", "height"],
      );

  @override
  void crateApiSimpleDummy(
      {required PoolBalance a1,
      required Spending a2,
      required TxTimeValue a3,
      required Quote a4,
      required Fee a5,
      required Progress a6,
      required Contact a7,
      required TxMemo a8,
      required ShieldedNote a9,
      required ParsedMemo a10,
      required SendContext a11,
      required PaymentURI a12,
      required Recipient a13,
      required Amount a14,
      required SwapAmount a15}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_pool_balance(a1, serializer);
        sse_encode_box_autoadd_spending(a2, serializer);
        sse_encode_box_autoadd_tx_time_value(a3, serializer);
        sse_encode_box_autoadd_quote(a4, serializer);
        sse_encode_box_autoadd_fee(a5, serializer);
        sse_encode_box_autoadd_progress(a6, serializer);
        sse_encode_box_autoadd_contact(a7, serializer);
        sse_encode_box_autoadd_tx_memo(a8, serializer);
        sse_encode_box_autoadd_shielded_note(a9, serializer);
        sse_encode_box_autoadd_parsed_memo(a10, serializer);
        sse_encode_box_autoadd_send_context(a11, serializer);
        sse_encode_box_autoadd_payment_uri(a12, serializer);
        sse_encode_box_autoadd_recipient(a13, serializer);
        sse_encode_box_autoadd_amount(a14, serializer);
        sse_encode_box_autoadd_swap_amount(a15, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleDummyConstMeta,
      argValues: [
        a1,
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14,
        a15
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleDummyConstMeta => const TaskConstMeta(
        debugName: "dummy",
        argNames: [
          "a1",
          "a2",
          "a3",
          "a4",
          "a5",
          "a6",
          "a7",
          "a8",
          "a9",
          "a10",
          "a11",
          "a12",
          "a13",
          "a14",
          "a15"
        ],
      );

  @override
  Backup crateApiSimpleGetBackup({required int coin, required int id}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        sse_encode_u_32(id, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_backup,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetBackupConstMeta,
      argValues: [coin, id],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetBackupConstMeta => const TaskConstMeta(
        debugName: "getBackup",
        argNames: ["coin", "id"],
      );

  @override
  Future<BigInt> crateApiSimpleGetBalance({required String filepath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filepath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetBalanceConstMeta,
      argValues: [filepath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetBalanceConstMeta => const TaskConstMeta(
        debugName: "get_balance",
        argNames: ["filepath"],
      );

  @override
  Future<List<Contact>> crateApiWarpGetContacts({required int coin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_contact,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWarpGetContactsConstMeta,
      argValues: [coin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpGetContactsConstMeta => const TaskConstMeta(
        debugName: "get_contacts",
        argNames: ["coin"],
      );

  @override
  BlockHeight crateApiWarpGetDbHeight({required int coin}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_block_height,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWarpGetDbHeightConstMeta,
      argValues: [coin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpGetDbHeightConstMeta => const TaskConstMeta(
        debugName: "get_db_height",
        argNames: ["coin"],
      );

  @override
  String crateApiWarpGetDiversifiedAddress(
      {required int coin,
      required int id,
      required int mask,
      required int time}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        sse_encode_u_32(id, serializer);
        sse_encode_u_8(mask, serializer);
        sse_encode_u_32(time, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 10)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWarpGetDiversifiedAddressConstMeta,
      argValues: [coin, id, mask, time],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpGetDiversifiedAddressConstMeta =>
      const TaskConstMeta(
        debugName: "get_diversified_address",
        argNames: ["coin", "id", "mask", "time"],
      );

  @override
  Future<Election> crateApiSimpleGetElection({required String filepath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filepath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_election,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleGetElectionConstMeta,
      argValues: [filepath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGetElectionConstMeta => const TaskConstMeta(
        debugName: "get_election",
        argNames: ["filepath"],
      );

  @override
  int crateApiWarpGetFirstAccount({required int coin}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 12)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_8,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWarpGetFirstAccountConstMeta,
      argValues: [coin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpGetFirstAccountConstMeta =>
      const TaskConstMeta(
        debugName: "get_first_account",
        argNames: ["coin"],
      );

  @override
  Future<int> crateApiWarpGetLatestHeight({required int coin}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWarpGetLatestHeightConstMeta,
      argValues: [coin],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpGetLatestHeightConstMeta =>
      const TaskConstMeta(
        debugName: "get_latest_height",
        argNames: ["coin"],
      );

  @override
  Future<List<TxTimeValue>> crateApiWarpGetPnlTxs(
      {required int coin, required int id, required int start}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        sse_encode_u_32(id, serializer);
        sse_encode_u_32(start, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_tx_time_value,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWarpGetPnlTxsConstMeta,
      argValues: [coin, id, start],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpGetPnlTxsConstMeta => const TaskConstMeta(
        debugName: "get_pnl_txs",
        argNames: ["coin", "id", "start"],
      );

  @override
  PoolBalance crateApiWarpGetPoolBalances(
      {required int coin,
      required int id,
      required int confs,
      required bool unconfirmed}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        sse_encode_u_32(id, serializer);
        sse_encode_u_32(confs, serializer);
        sse_encode_bool(unconfirmed, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_pool_balance,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWarpGetPoolBalancesConstMeta,
      argValues: [coin, id, confs, unconfirmed],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpGetPoolBalancesConstMeta =>
      const TaskConstMeta(
        debugName: "get_pool_balances",
        argNames: ["coin", "id", "confs", "unconfirmed"],
      );

  @override
  String? crateApiWarpGetProperty({required int coin, required String name}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        sse_encode_String(name, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 16)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWarpGetPropertyConstMeta,
      argValues: [coin, name],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpGetPropertyConstMeta => const TaskConstMeta(
        debugName: "get_property",
        argNames: ["coin", "name"],
      );

  @override
  Future<List<Spending>> crateApiWarpGetSpendings(
      {required int coin, required int id, required int start}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        sse_encode_u_32(id, serializer);
        sse_encode_u_32(start, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_spending,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWarpGetSpendingsConstMeta,
      argValues: [coin, id, start],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpGetSpendingsConstMeta => const TaskConstMeta(
        debugName: "get_spendings",
        argNames: ["coin", "id", "start"],
      );

  @override
  Future<void> crateApiSimpleInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  void crateApiWarpInitProver(
      {required List<int> spend, required List<int> output}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(spend, serializer);
        sse_encode_list_prim_u_8_loose(output, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 19)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWarpInitProverConstMeta,
      argValues: [spend, output],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpInitProverConstMeta => const TaskConstMeta(
        debugName: "init_prover",
        argNames: ["spend", "output"],
      );

  @override
  void crateApiWarpInitWallet({required int coin, required String path}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        sse_encode_String(path, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 20)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWarpInitWalletConstMeta,
      argValues: [coin, path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpInitWalletConstMeta => const TaskConstMeta(
        debugName: "init_wallet",
        argNames: ["coin", "path"],
      );

  @override
  Future<List<Vote>> crateApiSimpleListVotes({required String filepath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filepath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_vote,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleListVotesConstMeta,
      argValues: [filepath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleListVotesConstMeta => const TaskConstMeta(
        debugName: "list_votes",
        argNames: ["filepath"],
      );

  @override
  void crateApiWarpRescanFrom({required int coin, required int height}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        sse_encode_u_32(height, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 22)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWarpRescanFromConstMeta,
      argValues: [coin, height],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpRescanFromConstMeta => const TaskConstMeta(
        debugName: "rescan_from",
        argNames: ["coin", "height"],
      );

  @override
  void crateApiWarpSetDbPasswd({required int coin, required String password}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        sse_encode_String(password, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 23)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWarpSetDbPasswdConstMeta,
      argValues: [coin, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpSetDbPasswdConstMeta => const TaskConstMeta(
        debugName: "set_db_passwd",
        argNames: ["coin", "password"],
      );

  @override
  List<String> crateApiWarpSplitData(
      {required int id, required List<int> data}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(id, serializer);
        sse_encode_list_prim_u_8_loose(data, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 24)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWarpSplitDataConstMeta,
      argValues: [id, data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpSplitDataConstMeta => const TaskConstMeta(
        debugName: "split_data",
        argNames: ["id", "data"],
      );

  @override
  void crateApiWarpStoreContact(
      {required int coin,
      required int id,
      required Contact contact,
      required bool dirty}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        sse_encode_u_32(id, serializer);
        sse_encode_box_autoadd_contact(contact, serializer);
        sse_encode_bool(dirty, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWarpStoreContactConstMeta,
      argValues: [coin, id, contact, dirty],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpStoreContactConstMeta => const TaskConstMeta(
        debugName: "store_contact",
        argNames: ["coin", "id", "contact", "dirty"],
      );

  @override
  Future<void> crateApiSimpleSynchronize({required String filepath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filepath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleSynchronizeConstMeta,
      argValues: [filepath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleSynchronizeConstMeta => const TaskConstMeta(
        debugName: "synchronize",
        argNames: ["filepath"],
      );

  @override
  void crateApiWarpUpdateLwd({required int coin, required String url}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        sse_encode_String(url, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 27)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiWarpUpdateLwdConstMeta,
      argValues: [coin, url],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiWarpUpdateLwdConstMeta => const TaskConstMeta(
        debugName: "update_lwd",
        argNames: ["coin", "url"],
      );

  @override
  Future<String> crateApiSimpleVote(
      {required String filepath,
      required String address,
      required BigInt amount}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(filepath, serializer);
        sse_encode_String(address, serializer);
        sse_encode_u_64(amount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleVoteConstMeta,
      argValues: [filepath, address, amount],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleVoteConstMeta => const TaskConstMeta(
        debugName: "vote",
        argNames: ["filepath", "address", "amount"],
      );

  @override
  Stream<Progress> crateApiWarpWarpSync(
      {required int coin,
      required int id,
      required bool incTxs,
      required int confs,
      required int maxActions}) {
    final progress = RustStreamSink<Progress>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_8(coin, serializer);
        sse_encode_u_32(id, serializer);
        sse_encode_bool(incTxs, serializer);
        sse_encode_u_32(confs, serializer);
        sse_encode_u_32(maxActions, serializer);
        sse_encode_StreamSink_progress_Sse(progress, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiWarpWarpSyncConstMeta,
      argValues: [coin, id, incTxs, confs, maxActions, progress],
      apiImpl: this,
    )));
    return progress.stream;
  }

  TaskConstMeta get kCrateApiWarpWarpSyncConstMeta => const TaskConstMeta(
        debugName: "warp_sync",
        argNames: ["coin", "id", "incTxs", "confs", "maxActions", "progress"],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  RustStreamSink<Progress> dco_decode_StreamSink_progress_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<int> dco_decode_StreamSink_u_32_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  Amount dco_decode_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Amount(
      value: dco_decode_u_64(arr[0]),
      deductFee: dco_decode_bool(arr[1]),
    );
  }

  @protected
  Backup dco_decode_backup(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return Backup(
      name: dco_decode_String(arr[0]),
      seed: dco_decode_opt_String(arr[1]),
      index: dco_decode_u_32(arr[2]),
      sk: dco_decode_opt_String(arr[3]),
      fvk: dco_decode_String(arr[4]),
      uvk: dco_decode_String(arr[5]),
      tsk: dco_decode_opt_String(arr[6]),
      saved: dco_decode_bool(arr[7]),
    );
  }

  @protected
  BlockHeight dco_decode_block_height(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BlockHeight(
      height: dco_decode_u_32(arr[0]),
      timestamp: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  Amount dco_decode_box_autoadd_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_amount(raw);
  }

  @protected
  Contact dco_decode_box_autoadd_contact(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_contact(raw);
  }

  @protected
  Fee dco_decode_box_autoadd_fee(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_fee(raw);
  }

  @protected
  ParsedMemo dco_decode_box_autoadd_parsed_memo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_parsed_memo(raw);
  }

  @protected
  PaymentURI dco_decode_box_autoadd_payment_uri(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_uri(raw);
  }

  @protected
  PoolBalance dco_decode_box_autoadd_pool_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_pool_balance(raw);
  }

  @protected
  Progress dco_decode_box_autoadd_progress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_progress(raw);
  }

  @protected
  Quote dco_decode_box_autoadd_quote(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_quote(raw);
  }

  @protected
  Recipient dco_decode_box_autoadd_recipient(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_recipient(raw);
  }

  @protected
  SendContext dco_decode_box_autoadd_send_context(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_send_context(raw);
  }

  @protected
  ShieldedNote dco_decode_box_autoadd_shielded_note(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_shielded_note(raw);
  }

  @protected
  Spending dco_decode_box_autoadd_spending(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_spending(raw);
  }

  @protected
  SwapAmount dco_decode_box_autoadd_swap_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_swap_amount(raw);
  }

  @protected
  TxMemo dco_decode_box_autoadd_tx_memo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_tx_memo(raw);
  }

  @protected
  TxTimeValue dco_decode_box_autoadd_tx_time_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_tx_time_value(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  Choice dco_decode_choice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Choice(
      choice: dco_decode_String(arr[0]),
      address: dco_decode_String(arr[1]),
    );
  }

  @protected
  Contact dco_decode_contact(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Contact(
      id: dco_decode_u_32(arr[0]),
      name: dco_decode_String(arr[1]),
      address: dco_decode_String(arr[2]),
    );
  }

  @protected
  Election dco_decode_election(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return Election(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      startHeight: dco_decode_u_32(arr[2]),
      endHeight: dco_decode_u_32(arr[3]),
      question: dco_decode_String(arr[4]),
      candidates: dco_decode_list_choice(arr[5]),
      signatureRequired: dco_decode_bool(arr[6]),
      address: dco_decode_String(arr[7]),
      downloaded: dco_decode_bool(arr[8]),
    );
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  Fee dco_decode_fee(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Fee(
      scheme: dco_decode_u_8(arr[0]),
      fee: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<Choice> dco_decode_list_choice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_choice).toList();
  }

  @protected
  List<Contact> dco_decode_list_contact(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_contact).toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<Spending> dco_decode_list_spending(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_spending).toList();
  }

  @protected
  List<TxTimeValue> dco_decode_list_tx_time_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_tx_time_value).toList();
  }

  @protected
  List<Vote> dco_decode_list_vote(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_vote).toList();
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  ParsedMemo dco_decode_parsed_memo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ParsedMemo(
      reply: dco_decode_bool(arr[0]),
      subject: dco_decode_String(arr[1]),
      memo: dco_decode_String(arr[2]),
    );
  }

  @protected
  PaymentURI dco_decode_payment_uri(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PaymentURI(
      address: dco_decode_String(arr[0]),
      amount: dco_decode_u_64(arr[1]),
      memo: dco_decode_String(arr[2]),
    );
  }

  @protected
  PoolBalance dco_decode_pool_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PoolBalance(
      transparent: dco_decode_u_64(arr[0]),
      sapling: dco_decode_u_64(arr[1]),
      orchard: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  Progress dco_decode_progress(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return Progress(
      timestamp: dco_decode_u_32(arr[0]),
      trialDecryptions: dco_decode_u_32(arr[1]),
      height: dco_decode_u_32(arr[2]),
      downloaded: dco_decode_u_32(arr[3]),
    );
  }

  @protected
  Quote dco_decode_quote(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Quote(
      timestamp: dco_decode_u_32(arr[0]),
      price: dco_decode_f_64(arr[1]),
    );
  }

  @protected
  Recipient dco_decode_recipient(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return Recipient(
      address: dco_decode_String(arr[0]),
      pools: dco_decode_u_8(arr[1]),
      amount: dco_decode_u_64(arr[2]),
      message: dco_decode_parsed_memo(arr[3]),
    );
  }

  @protected
  SendContext dco_decode_send_context(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return SendContext(
      address: dco_decode_String(arr[0]),
      pools: dco_decode_u_8(arr[1]),
      amount: dco_decode_u_64(arr[2]),
      receiverFee: dco_decode_bool(arr[3]),
      memo: dco_decode_parsed_memo(arr[4]),
    );
  }

  @protected
  ShieldedNote dco_decode_shielded_note(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return ShieldedNote(
      id: dco_decode_u_32(arr[0]),
      height: dco_decode_u_32(arr[1]),
      value: dco_decode_u_64(arr[2]),
      timestamp: dco_decode_u_32(arr[3]),
      orchard: dco_decode_bool(arr[4]),
      excluded: dco_decode_bool(arr[5]),
      spent: dco_decode_bool(arr[6]),
    );
  }

  @protected
  Spending dco_decode_spending(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Spending(
      recipient: dco_decode_String(arr[0]),
      amount: dco_decode_i_64(arr[1]),
    );
  }

  @protected
  SwapAmount dco_decode_swap_amount(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SwapAmount(
      amount: dco_decode_String(arr[0]),
      currency: dco_decode_String(arr[1]),
    );
  }

  @protected
  TxMemo dco_decode_tx_memo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return TxMemo(
      direction: dco_decode_u_8(arr[0]),
      address: dco_decode_String(arr[1]),
      memo: dco_decode_String(arr[2]),
    );
  }

  @protected
  TxTimeValue dco_decode_tx_time_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return TxTimeValue(
      timestamp: dco_decode_u_32(arr[0]),
      value: dco_decode_i_64(arr[1]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  Vote dco_decode_vote(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return Vote(
      hash: dco_decode_String(arr[0]),
      address: dco_decode_String(arr[1]),
      amount: dco_decode_u_64(arr[2]),
      height: dco_decode_opt_box_autoadd_u_32(arr[3]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  RustStreamSink<Progress> sse_decode_StreamSink_progress_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<int> sse_decode_StreamSink_u_32_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  Amount sse_decode_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_value = sse_decode_u_64(deserializer);
    var var_deductFee = sse_decode_bool(deserializer);
    return Amount(value: var_value, deductFee: var_deductFee);
  }

  @protected
  Backup sse_decode_backup(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_seed = sse_decode_opt_String(deserializer);
    var var_index = sse_decode_u_32(deserializer);
    var var_sk = sse_decode_opt_String(deserializer);
    var var_fvk = sse_decode_String(deserializer);
    var var_uvk = sse_decode_String(deserializer);
    var var_tsk = sse_decode_opt_String(deserializer);
    var var_saved = sse_decode_bool(deserializer);
    return Backup(
        name: var_name,
        seed: var_seed,
        index: var_index,
        sk: var_sk,
        fvk: var_fvk,
        uvk: var_uvk,
        tsk: var_tsk,
        saved: var_saved);
  }

  @protected
  BlockHeight sse_decode_block_height(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_height = sse_decode_u_32(deserializer);
    var var_timestamp = sse_decode_u_32(deserializer);
    return BlockHeight(height: var_height, timestamp: var_timestamp);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  Amount sse_decode_box_autoadd_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_amount(deserializer));
  }

  @protected
  Contact sse_decode_box_autoadd_contact(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_contact(deserializer));
  }

  @protected
  Fee sse_decode_box_autoadd_fee(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_fee(deserializer));
  }

  @protected
  ParsedMemo sse_decode_box_autoadd_parsed_memo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_parsed_memo(deserializer));
  }

  @protected
  PaymentURI sse_decode_box_autoadd_payment_uri(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_uri(deserializer));
  }

  @protected
  PoolBalance sse_decode_box_autoadd_pool_balance(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_pool_balance(deserializer));
  }

  @protected
  Progress sse_decode_box_autoadd_progress(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_progress(deserializer));
  }

  @protected
  Quote sse_decode_box_autoadd_quote(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_quote(deserializer));
  }

  @protected
  Recipient sse_decode_box_autoadd_recipient(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_recipient(deserializer));
  }

  @protected
  SendContext sse_decode_box_autoadd_send_context(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_send_context(deserializer));
  }

  @protected
  ShieldedNote sse_decode_box_autoadd_shielded_note(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_shielded_note(deserializer));
  }

  @protected
  Spending sse_decode_box_autoadd_spending(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_spending(deserializer));
  }

  @protected
  SwapAmount sse_decode_box_autoadd_swap_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_swap_amount(deserializer));
  }

  @protected
  TxMemo sse_decode_box_autoadd_tx_memo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_tx_memo(deserializer));
  }

  @protected
  TxTimeValue sse_decode_box_autoadd_tx_time_value(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_tx_time_value(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  Choice sse_decode_choice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_choice = sse_decode_String(deserializer);
    var var_address = sse_decode_String(deserializer);
    return Choice(choice: var_choice, address: var_address);
  }

  @protected
  Contact sse_decode_contact(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_u_32(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_address = sse_decode_String(deserializer);
    return Contact(id: var_id, name: var_name, address: var_address);
  }

  @protected
  Election sse_decode_election(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_startHeight = sse_decode_u_32(deserializer);
    var var_endHeight = sse_decode_u_32(deserializer);
    var var_question = sse_decode_String(deserializer);
    var var_candidates = sse_decode_list_choice(deserializer);
    var var_signatureRequired = sse_decode_bool(deserializer);
    var var_address = sse_decode_String(deserializer);
    var var_downloaded = sse_decode_bool(deserializer);
    return Election(
        id: var_id,
        name: var_name,
        startHeight: var_startHeight,
        endHeight: var_endHeight,
        question: var_question,
        candidates: var_candidates,
        signatureRequired: var_signatureRequired,
        address: var_address,
        downloaded: var_downloaded);
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  Fee sse_decode_fee(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_scheme = sse_decode_u_8(deserializer);
    var var_fee = sse_decode_u_64(deserializer);
    return Fee(scheme: var_scheme, fee: var_fee);
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<Choice> sse_decode_list_choice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Choice>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_choice(deserializer));
    }
    return ans_;
  }

  @protected
  List<Contact> sse_decode_list_contact(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Contact>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_contact(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<Spending> sse_decode_list_spending(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Spending>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_spending(deserializer));
    }
    return ans_;
  }

  @protected
  List<TxTimeValue> sse_decode_list_tx_time_value(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TxTimeValue>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_tx_time_value(deserializer));
    }
    return ans_;
  }

  @protected
  List<Vote> sse_decode_list_vote(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Vote>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_vote(deserializer));
    }
    return ans_;
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ParsedMemo sse_decode_parsed_memo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_reply = sse_decode_bool(deserializer);
    var var_subject = sse_decode_String(deserializer);
    var var_memo = sse_decode_String(deserializer);
    return ParsedMemo(reply: var_reply, subject: var_subject, memo: var_memo);
  }

  @protected
  PaymentURI sse_decode_payment_uri(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_address = sse_decode_String(deserializer);
    var var_amount = sse_decode_u_64(deserializer);
    var var_memo = sse_decode_String(deserializer);
    return PaymentURI(address: var_address, amount: var_amount, memo: var_memo);
  }

  @protected
  PoolBalance sse_decode_pool_balance(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_transparent = sse_decode_u_64(deserializer);
    var var_sapling = sse_decode_u_64(deserializer);
    var var_orchard = sse_decode_u_64(deserializer);
    return PoolBalance(
        transparent: var_transparent,
        sapling: var_sapling,
        orchard: var_orchard);
  }

  @protected
  Progress sse_decode_progress(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_timestamp = sse_decode_u_32(deserializer);
    var var_trialDecryptions = sse_decode_u_32(deserializer);
    var var_height = sse_decode_u_32(deserializer);
    var var_downloaded = sse_decode_u_32(deserializer);
    return Progress(
        timestamp: var_timestamp,
        trialDecryptions: var_trialDecryptions,
        height: var_height,
        downloaded: var_downloaded);
  }

  @protected
  Quote sse_decode_quote(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_timestamp = sse_decode_u_32(deserializer);
    var var_price = sse_decode_f_64(deserializer);
    return Quote(timestamp: var_timestamp, price: var_price);
  }

  @protected
  Recipient sse_decode_recipient(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_address = sse_decode_String(deserializer);
    var var_pools = sse_decode_u_8(deserializer);
    var var_amount = sse_decode_u_64(deserializer);
    var var_message = sse_decode_parsed_memo(deserializer);
    return Recipient(
        address: var_address,
        pools: var_pools,
        amount: var_amount,
        message: var_message);
  }

  @protected
  SendContext sse_decode_send_context(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_address = sse_decode_String(deserializer);
    var var_pools = sse_decode_u_8(deserializer);
    var var_amount = sse_decode_u_64(deserializer);
    var var_receiverFee = sse_decode_bool(deserializer);
    var var_memo = sse_decode_parsed_memo(deserializer);
    return SendContext(
        address: var_address,
        pools: var_pools,
        amount: var_amount,
        receiverFee: var_receiverFee,
        memo: var_memo);
  }

  @protected
  ShieldedNote sse_decode_shielded_note(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_u_32(deserializer);
    var var_height = sse_decode_u_32(deserializer);
    var var_value = sse_decode_u_64(deserializer);
    var var_timestamp = sse_decode_u_32(deserializer);
    var var_orchard = sse_decode_bool(deserializer);
    var var_excluded = sse_decode_bool(deserializer);
    var var_spent = sse_decode_bool(deserializer);
    return ShieldedNote(
        id: var_id,
        height: var_height,
        value: var_value,
        timestamp: var_timestamp,
        orchard: var_orchard,
        excluded: var_excluded,
        spent: var_spent);
  }

  @protected
  Spending sse_decode_spending(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_recipient = sse_decode_String(deserializer);
    var var_amount = sse_decode_i_64(deserializer);
    return Spending(recipient: var_recipient, amount: var_amount);
  }

  @protected
  SwapAmount sse_decode_swap_amount(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_amount = sse_decode_String(deserializer);
    var var_currency = sse_decode_String(deserializer);
    return SwapAmount(amount: var_amount, currency: var_currency);
  }

  @protected
  TxMemo sse_decode_tx_memo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_direction = sse_decode_u_8(deserializer);
    var var_address = sse_decode_String(deserializer);
    var var_memo = sse_decode_String(deserializer);
    return TxMemo(
        direction: var_direction, address: var_address, memo: var_memo);
  }

  @protected
  TxTimeValue sse_decode_tx_time_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_timestamp = sse_decode_u_32(deserializer);
    var var_value = sse_decode_i_64(deserializer);
    return TxTimeValue(timestamp: var_timestamp, value: var_value);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  Vote sse_decode_vote(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hash = sse_decode_String(deserializer);
    var var_address = sse_decode_String(deserializer);
    var var_amount = sse_decode_u_64(deserializer);
    var var_height = sse_decode_opt_box_autoadd_u_32(deserializer);
    return Vote(
        hash: var_hash,
        address: var_address,
        amount: var_amount,
        height: var_height);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_StreamSink_progress_Sse(
      RustStreamSink<Progress> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_progress,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_u_32_Sse(
      RustStreamSink<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_amount(Amount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.value, serializer);
    sse_encode_bool(self.deductFee, serializer);
  }

  @protected
  void sse_encode_backup(Backup self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_opt_String(self.seed, serializer);
    sse_encode_u_32(self.index, serializer);
    sse_encode_opt_String(self.sk, serializer);
    sse_encode_String(self.fvk, serializer);
    sse_encode_String(self.uvk, serializer);
    sse_encode_opt_String(self.tsk, serializer);
    sse_encode_bool(self.saved, serializer);
  }

  @protected
  void sse_encode_block_height(BlockHeight self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.height, serializer);
    sse_encode_u_32(self.timestamp, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_amount(Amount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_amount(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_contact(Contact self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_contact(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_fee(Fee self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_fee(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_parsed_memo(
      ParsedMemo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_parsed_memo(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_uri(
      PaymentURI self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_uri(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_pool_balance(
      PoolBalance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pool_balance(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_progress(
      Progress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_progress(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_quote(Quote self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_quote(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_recipient(
      Recipient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_recipient(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_send_context(
      SendContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_send_context(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_shielded_note(
      ShieldedNote self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_shielded_note(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_spending(
      Spending self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_spending(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_swap_amount(
      SwapAmount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_swap_amount(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_tx_memo(TxMemo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_tx_memo(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_tx_time_value(
      TxTimeValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_tx_time_value(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_choice(Choice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.choice, serializer);
    sse_encode_String(self.address, serializer);
  }

  @protected
  void sse_encode_contact(Contact self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.address, serializer);
  }

  @protected
  void sse_encode_election(Election self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_u_32(self.startHeight, serializer);
    sse_encode_u_32(self.endHeight, serializer);
    sse_encode_String(self.question, serializer);
    sse_encode_list_choice(self.candidates, serializer);
    sse_encode_bool(self.signatureRequired, serializer);
    sse_encode_String(self.address, serializer);
    sse_encode_bool(self.downloaded, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_fee(Fee self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8(self.scheme, serializer);
    sse_encode_u_64(self.fee, serializer);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_choice(List<Choice> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_choice(item, serializer);
    }
  }

  @protected
  void sse_encode_list_contact(List<Contact> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_contact(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_spending(List<Spending> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_spending(item, serializer);
    }
  }

  @protected
  void sse_encode_list_tx_time_value(
      List<TxTimeValue> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_tx_time_value(item, serializer);
    }
  }

  @protected
  void sse_encode_list_vote(List<Vote> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_vote(item, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_parsed_memo(ParsedMemo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.reply, serializer);
    sse_encode_String(self.subject, serializer);
    sse_encode_String(self.memo, serializer);
  }

  @protected
  void sse_encode_payment_uri(PaymentURI self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.address, serializer);
    sse_encode_u_64(self.amount, serializer);
    sse_encode_String(self.memo, serializer);
  }

  @protected
  void sse_encode_pool_balance(PoolBalance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.transparent, serializer);
    sse_encode_u_64(self.sapling, serializer);
    sse_encode_u_64(self.orchard, serializer);
  }

  @protected
  void sse_encode_progress(Progress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.timestamp, serializer);
    sse_encode_u_32(self.trialDecryptions, serializer);
    sse_encode_u_32(self.height, serializer);
    sse_encode_u_32(self.downloaded, serializer);
  }

  @protected
  void sse_encode_quote(Quote self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.timestamp, serializer);
    sse_encode_f_64(self.price, serializer);
  }

  @protected
  void sse_encode_recipient(Recipient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.address, serializer);
    sse_encode_u_8(self.pools, serializer);
    sse_encode_u_64(self.amount, serializer);
    sse_encode_parsed_memo(self.message, serializer);
  }

  @protected
  void sse_encode_send_context(SendContext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.address, serializer);
    sse_encode_u_8(self.pools, serializer);
    sse_encode_u_64(self.amount, serializer);
    sse_encode_bool(self.receiverFee, serializer);
    sse_encode_parsed_memo(self.memo, serializer);
  }

  @protected
  void sse_encode_shielded_note(ShieldedNote self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.id, serializer);
    sse_encode_u_32(self.height, serializer);
    sse_encode_u_64(self.value, serializer);
    sse_encode_u_32(self.timestamp, serializer);
    sse_encode_bool(self.orchard, serializer);
    sse_encode_bool(self.excluded, serializer);
    sse_encode_bool(self.spent, serializer);
  }

  @protected
  void sse_encode_spending(Spending self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.recipient, serializer);
    sse_encode_i_64(self.amount, serializer);
  }

  @protected
  void sse_encode_swap_amount(SwapAmount self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.amount, serializer);
    sse_encode_String(self.currency, serializer);
  }

  @protected
  void sse_encode_tx_memo(TxMemo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8(self.direction, serializer);
    sse_encode_String(self.address, serializer);
    sse_encode_String(self.memo, serializer);
  }

  @protected
  void sse_encode_tx_time_value(TxTimeValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.timestamp, serializer);
    sse_encode_i_64(self.value, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_vote(Vote self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.hash, serializer);
    sse_encode_String(self.address, serializer);
    sse_encode_u_64(self.amount, serializer);
    sse_encode_opt_box_autoadd_u_32(self.height, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }
}
